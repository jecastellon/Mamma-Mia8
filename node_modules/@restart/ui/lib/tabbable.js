function isInput(node) {
  return (node == null ? void 0 : node.tagName) === 'INPUT';
}
function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  const radioScope = node.form || node.ownerDocument;
  const radioSet = Array.from(radioScope.querySelectorAll(`input[type="radio"][name="${escape(node.name)}"]`));
  const {
    form
  } = node;
  const checked = radioSet.find(input => input.checked && input.form === form);
  return !checked || checked === node;
}
function isInDisabledFieldset(node) {
  return !!node && node.matches('fieldset[disabled] *');
}
function isFocusableElementMatchingSelector(element) {
  return !element.disabled && !isInDisabledFieldset(element) && !(isInput(element) && element.type === 'hidden');
}
function isTabbableElementMatchingSelector(element) {
  if (isInput(element) && element.type === 'radio' && !isTabbableRadio(element)) {
    return false;
  }
  if (element.tabIndex < 0) {
    return false;
  }
  return isFocusableElementMatchingSelector(element);
}

// An incomplete set of selectors for HTML elements that are focusable.
// Goal here is to cover 95% of the cases.
const FOCUSABLE_SELECTOR = ['input', 'textarea', 'select', 'button', 'a[href]', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',');
const isFocusable = element => element.matches(FOCUSABLE_SELECTOR) && isFocusableElementMatchingSelector(element);
export function getTabbableElements(container, startAt) {
  let items = Array.from(container.querySelectorAll(FOCUSABLE_SELECTOR));
  if (startAt) {
    const startIndex = items.indexOf(startAt);
    if (startIndex !== -1) {
      items = items.slice(startIndex);
    }
  }
  return items.filter(isTabbableElementMatchingSelector);
}
export function getTabbableElementsOrSelf(container) {
  const tabbables = getTabbableElements(container);
  return tabbables.length ? tabbables : isFocusable(container) ? [container] : [];
}